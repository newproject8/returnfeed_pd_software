https://docs.ndi.video/all/getting-started/white-paper
ndi 공식 기술문서이다. 링크 참조해 철저 분석하라.

# "클래식 모드" NDI 프레임레이트 저하 문제 해결 방안 (v3 - 최종)

## 1. 문제 요약

`run_classic.bat`으로 실행되는 "클래식 모드" 애플리케이션에서 NDI 비디오 스트림 수신 시 심각한 프레임레이트 저하와 UI 반응성 저하 문제가 발생합니다.

## 2. 근본 원인 분석 (NDI 공식 지침 기반)

심층 분석 결과, 문제의 핵심 원인은 **메인 UI 스레드의 과도한 부담**입니다. 이는 NDI 공식 기술 백서에서 지적하는 성능 저하 요인과 정확히 일치합니다.

*   **잘못된 스레딩 모델:** NDI 공식 문서는 프레임 수신을 **별도의 전용 스레드**에서 처리할 것을 강력히 권장합니다. 하지만 현재 구조는 수신 스레드와 UI 스레드 간의 비효율적인 데이터 전달로 인해 사실상 UI 스레드에 모든 부담을 전가하고 있습니다.

*   **CPU 기반의 무거운 렌더링:** 공식 백서는 **CPU 기반 렌더링이 심각한 성능 저하를 유발**하므로, 색상 변환과 최종 렌더링은 **반드시 GPU가 전담**해야 한다고 강조합니다. 현재 `NDIWidget`의 `paintEvent`는 이 원칙에 정면으로 위배됩니다.

*   **비효율적인 데이터 처리:** 스레드 간 `QImage` 객체 복사는 대용량 프레임 데이터를 반복적으로 복사하여 막대한 오버헤드를 유발합니다.

## 3. 제안 해결책: NDI 공식 권장 아키텍처 도입

문제 해결을 위해, NDI 공식 기술 백서에서 권장하는 **GPU 가속 렌더링 아키텍처**를 도입할 것을 제안합니다. 이는 `QWidget` 기반의 `NDIWidget`을 `QOpenGLWidget`으로 교체하는 것을 핵심으로 합니다.

**NDI 공식 권장 사항:**
> *"최상의 성능을 위해, NDI 프레임 수신은 별도의 스레드에서 처리하고, 디코딩된 프레임은 GPU를 사용하여 렌더링해야 합니다. `NDIlib_recv_color_format_BGRX_BGRA` 포맷은 CPU에서의 추가 변환 없이 GPU에서 직접 처리할 수 있어 가장 효율적입니다."*

**새로운 아키텍처:**

1.  **`NDIReceiver` (수신 스레드):** NDI 프레임을 수신하여 **`BGRX_BGRA`** 포맷의 원본 데이터(NumPy 배열)를 생산자-소비자 큐에 넣습니다.
2.  **데이터 전달:** 데이터 복사를 피하기 위해 **공유 메모리**나 **메모리 포인터**를 사용하여 렌더링 스레드에 데이터의 위치만 알립니다.
3.  **`NDIWidget` (`QOpenGLWidget` - 렌더링 스레드):**
    *   `initializeGL()`: 렌더링에 필요한 OpenGL 셰이더와 텍스처 객체를 초기화합니다.
    *   `paintGL()`: 큐에서 프레임 데이터 위치를 가져와 GPU 메모리(텍스처)로 직접 업로드하고, 셰이더를 통해 화면에 그리는 명령을 GPU에 전달합니다.

## 4. 실행 계획

1.  **`NDIWidget` 리팩토링:** `NDIWidget`의 기반 클래스를 `QWidget`에서 `QOpenGLWidget`으로 변경합니다.
2.  **OpenGL 렌더링 구현:** `paintGL`, `initializeGL`, `resizeGL` 메서드를 구현합니다. GPU 텍스처 업로드 및 렌더링을 위한 GLSL 셰이더 코드를 작성합니다.
3.  **`NDIReceiver` 수정:** `NDIlib_recv_capture_v2` 호출 시 컬러 포맷을 **`NDIlib_recv_color_format_BGRX_BGRA`** 로 명시적으로 설정합니다. `QImage` 변환 로직을 제거하고 NumPy 배열을 큐에 넣도록 수정합니다.
4.  **메모리 관리 강화:** 프레임 사용 후 **`NDIlib_recv_free_video_v2`** 가 반드시 호출되도록 로직을 검토하고 수정합니다.
5.  **테스트 및 검증:** 리팩토링 후, NDI 소스의 원본 프레임레이트가 안정적으로 유지되는지, CPU 사용량이 현저히 감소하고 GPU 사용량이 적절히 나타나는지 프로파일링 도구를 통해 검증합니다.

## 5. 기대 효과

*   **프레임레이트 안정화:** UI 스레드의 병목이 완전히 해소되어 NDI 소스의 원본 프레임레이트를 안정적으로 표시합니다.
*   **시스템 리소스 효율화:** 렌더링 부하를 GPU로 이전하여 CPU 점유율을 대폭 낮추고 시스템 전반의 효율을 높입니다.
*   **UI 반응성 극대화:** 메인 UI 스레드가 렌더링 부담에서 완전히 해방되어 애플리케이션 전체의 반응성이 크게 향상됩니다.



NDI 프록시 스트림 프레임레이트 저하 현상에 대한 종합 분석 및 해결 전략섹션 1: NDI 프록시 스트림의 해부: 기본 원리와 불확실성1.1 이중 스트림 아키텍처: 목적과 의도NDI(Network Device Interface)의 근본적인 설계 원칙 중 하나는 송신자(Sender)가 두 종류의 스트림을 동시에 생성할 수 있다는 점입니다: 하나는 최고 품질의 '프로그램(Program)' 스트림이며, 다른 하나는 상대적으로 낮은 품질의 '프록시(Proxy)' 스트림입니다.1 이 아키텍처의 의도는 네트워크 효율성을 극대화하는 데 있습니다. 프록시 스트림은 전체 대역폭을 소모하지 않으면서 소스를 미리 보거나 모니터링해야 하는 애플리케이션(예: 멀티뷰어, 프리뷰 모니터)을 위해 설계되었습니다. 이러한 시나리오에서는 완전한 화질 충실도보다는 네트워크 대역폭 절약이 더 중요합니다. 이후 해당 소스가 실제 라이브 출력으로 전환될 때, 수신 애플리케이션은 프록시 스트림에서 전체 대역폭 스트림으로 원활하게 전환할 수 있습니다.1 이러한 방식은 수신 측에서 더 적은 네트워크 대역폭을 소비하면서도 더 많은 수의 NDI 소스를 관리할 수 있게 해줍니다.이러한 설계는 낮은 품질의 스트림 존재 자체가 버그가 아니라 의도된 기능임을 명확히 합니다. 따라서 사용자가 겪고 있는 문제의 핵심은 프록시 스트림의 존재 유무가 아니라, 그 성능이 예상보다 현저히 저하된다는 점에 있습니다.1.2 기술 사양: '블랙박스' 문제프록시 스트림의 기술적 특성을 이해하려는 시도는 중대한 장벽에 부딪힙니다. NDI SDK 공식 문서는 프록시 스트림을 "상당히 감소된 대역폭을 사용하는 중간 품질의 스트림"이라고 설명할 뿐입니다.2 이는 NDI High Bandwidth가 SpeedHQ 코덱을 사용하고 3, 다양한 NDI|HX 버전이 H.264 또는 H.265 코덱을 사용하는 것과 같이 명확한 기술 사양이 공개된 것과는 대조적입니다.5결정적으로, NDI 공식 문서는 프록시 스트림의 구체적인 기술적 특성을 공개하지 않고 있습니다. 이로 인해 개발자는 다음과 같은 핵심 변수들을 알 수 없습니다:사용되는 특정 비디오 코덱압축률 또는 목표 비트레이트GOP(Group of Pictures) 구조해상도 (원본의 고정된 비율인지, 가변적인지)크로마 서브샘플링 형식NDI 공식 기술 백서(White Paper)조차 프록시 스트림의 구체적인 코덱이나 압축률 같은 기술 사양을 명시하지 않아, 이러한 정보의 부재를 재확인시켜 줍니다.46 이러한 정보의 부재는 프록시 스트림이 개발자 입장에서 사실상 '블랙박스'처럼 취급될 수밖에 없음을 의미합니다. 개발자는 프록시 스트림의 디코딩 복잡성이나 성능 특성을 사전에 예측하거나 가정할 수 없으며, 이는 성능 문제의 근본적인 원인이 될 수 있습니다.1.3 SDK 구현: 프록시 스트림 요청 방법NDI 수신 인스턴스를 생성하는 진입점은 NDIlib_recv_create_v3 함수입니다.2 이 함수를 호출할 때 전달하는 구조체의 bandwidth 매개변수가 스트림 종류를 결정하는 핵심적인 역할을 합니다.NDIlib_recv_bandwidth_highest: 이 값을 지정하면 송신자로부터 최고 품질의 스트림(Full-bandwidth)을 요청합니다.NDIlib_recv_bandwidth_lowest: 이 값을 지정하면 대역폭이 낮은 프록시 스트림을 명시적으로 요청합니다.사용자의 문제 상황은 NDIlib_recv_bandwidth_lowest를 사용했을 때 발생하므로, 프록시 스트림 수신 로직과 직접적으로 관련이 있습니다.참고로 NDI 6.1 이상 버전의 Advanced SDK에는 NDIlib_recv_set_bandwidth라는 새로운 함수가 도입되었습니다. 이 함수를 사용하면 단일 수신기 인스턴스에서 고대역폭과 저대역폭 스트림을 동적으로 전환할 수 있어, 두 개의 개별 수신기를 생성해야 했던 기존 방식보다 오버헤드를 줄일 수 있습니다.7 이는 향후 애플리케이션 최적화에 유용한 기능이지만, 현재 겪고 있는 프레임레이트 저하 문제의 직접적인 원인은 아닙니다.이러한 분석을 통해, 문제의 본질이 '스트림이 손상되었는가?'가 아니라 '왜 나의 애플리케이션이 이 특정 프록시 스트림을 디코딩하는 데 어려움을 겪는가?'로 전환되어야 함을 알 수 있습니다. 전체 대역폭 스트림은 잘 정의된 SpeedHQ 코덱을 사용하므로 하드웨어 가속과 같은 고도로 최적화된 디코딩 경로를 활용할 가능성이 높습니다.4 반면, 사양이 불분명한 프록시 스트림은 이러한 최적화 경로를 사용하지 못하고, 덜 효율적인 CPU 기반 디코딩으로 대체(fallback)될 수 있습니다. 따라서 60fps에서 40~50fps로의 프레임레이트 저하는 수신 측의 CPU가 프록시 스트림을 실시간으로 디코딩하지 못해 발생하는 디코딩 성능 병목 현상일 가능성이 매우 높습니다.섹션 2: 근본 원인 분석: 애플리케이션 레벨 병목 현상2.1 프레임 수신 루프: 폴링(Polling) 대 블로킹(Blocking)NDI 프레임을 검색하는 핵심 메커니즘은 NDIlib_recv_capture_v3 함수이며, 이 함수의 timeout_in_ms 매개변수 사용 방식이 성능에 지대한 영향을 미칩니다.2시나리오 A: 논블로킹 "타이트 폴링" (timeout=0): while(true) { capture(0); }와 같이 지연 시간 없이 타이트 루프(tight loop)에서 이 함수를 호출하는 것은 흔하지만 매우 위험한 패턴입니다. 이는 가장 낮은 지연 시간을 제공하는 것처럼 보이지만, 실제로는 단일 CPU 코어의 사용률을 100%까지 끌어올릴 수 있습니다.9 이로 인해 NDI SDK의 내부 디코딩 스레드나 애플리케이션의 렌더링 스레드와 같은 다른 중요한 스레드들이 CPU 자원을 할당받지 못하는 '기아 상태(starvation)'에 빠지게 됩니다. 이는 연쇄적인 성능 문제와 프레임 드롭을 유발하는 직접적인 원인이 됩니다.시나리오 B: 블로킹 호출 (timeout > 0): 1000ms와 같이 0보다 큰 타임아웃 값을 제공하면, 수신할 프레임이 없을 경우 해당 스레드는 대기 상태로 전환되어 CPU를 다른 스레드에 양보합니다. 이는 CPU 자원을 낭비하는 '스피닝(spinning)'을 방지하고 운영체제가 다른 중요한 작업을 스케줄링할 수 있도록 하므로 훨씬 효율적인 접근 방식입니다. 만약 프레임이 이미 수신 큐에 대기 중이라면 함수는 즉시 반환되므로, 스트림 자체가 지연되지 않는 한 불필요한 지연 시간을 추가하지 않습니다.2 실제로 커뮤니티 포럼에서는 높은 CPU 사용률이 NDI 소스 자체가 아닌 수신기 애플리케이션의 구현 방식과 관련이 있다는 보고가 다수 존재합니다.102.2 스레딩 아키텍처: 우선순위, 선호도 및 경합실시간 비디오 처리는 신중한 스레드 관리를 요구합니다. NDI SDK는 NDIlib_recv_capture_v3 함수가 스레드에 안전(thread-safe)하므로, 오디오와 비디오 쿼리를 위해 별도의 스레드를 사용할 것을 권장합니다.8스레드 우선순위 (Thread Priority): 운영체제 스케줄러는 중요한 비디오 처리 스레드의 실행을 중단시키고 우선순위가 낮은 다른 작업을 먼저 처리할 수 있습니다. 이는 비디오의 끊김(stutter) 현상을 유발합니다. 따라서 비디오 처리 스레드의 우선순위를 높이는 것이 중요합니다. Windows에서는 ctypes 모듈을 사용하여 Win32 API를 호출하거나, Linux에서는 os.setpriority 함수를 사용하여 스레드 우선순위를 높일 수 있습니다. 다만, 파이썬의 경우 GIL(Global Interpreter Lock)로 인해 스레드 우선순위 제어에 일부 한계가 존재합니다.14CPU 선호도 (CPU Affinity): psutil 라이브러리나 os.sched_setaffinity와 같은 함수를 사용하여 특정 스레드를 특정 CPU 코어에 고정(pinning)하는 기술입니다.19 이는 스레드가 여러 코어 사이를 이동하면서 발생하는 컨텍스트 스위칭 오버헤드와 CPU 캐시 미스(cache miss)를 방지하여 실시간 성능을 크게 향상시킬 수 있습니다. 이는 Rust로 작성된 NDI 래퍼 라이브러리의 문서에서도 언급된 핵심적인 성능 고려 사항입니다.242.3 디코딩 부하: CPU 대 GPU의 분담전체 대역폭 스트림이 원활하게 재생된다는 사실은 해당 스트림이 GPU에서 디코딩될 가능성이 높다는 점을 시사합니다. 반면 프록시 스트림의 성능 저하는 CPU 디코딩으로의 대체(fallback)가 발생했음을 암시합니다.커뮤니티의 여러 사례에서 수신기 애플리케이션의 하드웨어 가속을 비활성화했을 때 심각한 성능 저하가 발생했거나 9, 반대로 GPU가 없는 시스템에서 NDI를 사용하자 CPU 사용률이 100%에 도달했다는 보고가 있습니다.12 최신 NDI SDK는 하드웨어 가속이 유용한 대부분의 상황에서 이를 기본적으로 사용하도록 설정되어 있지만 8, 프록시 스트림의 '블랙박스'적인 특성으로 인해 이 기능이 올바르게 활성화되지 않았을 수 있습니다.2.4 흔히 발생하는 SDK 구현 함정개발자 포럼 및 기술 자료를 분석한 결과, 다음과 같은 일반적인 구현 실수를 확인할 수 있었습니다.성급한 버퍼 해제: 한 Stack Overflow 사례에서는 비디오 프레임 버퍼를 사용하기도 전에 NDIlib_recv_free_video_v2를 호출하여 애플리케이션이 몇 프레임 만에 중단되는 문제가 보고되었습니다.26 프레임 데이터의 처리가 완전히 끝난 후에 버퍼를 해제해야 합니다.비동기 작업 관리 부실: Unreal Engine 사용 사례에서는 NDI 객체가 제대로 참조되지 않아 가비지 컬렉션(garbage collection)의 대상이 되어 60초 후에 연결이 끊어지는 현상이 보고되었습니다.27 이는 비동기 환경에서 객체의 생명주기(lifetime)를 신중하게 관리해야 함을 보여줍니다.타임스탬프와 타임코드의 혼동: obs-ndi 플러그인 관련 심층 분석에 따르면, NDI 프레임에 포함된 timestamp(송신 측 SDK에 프레임이 제출된 시간)와 timecode(Unix epoch 기반 시간, 보장되지는 않음)를 혼동하여 사용하는 경우가 있습니다. 내부 동기화를 위해 잘못된 값을 사용하면 오디오/비디오 드리프트나 끊김 현상이 발생할 수 있습니다.28부적절한 프레임 버퍼링: 또 다른 obs-ndi 이슈에서는 더 낮은 지연 시간을 얻기 위해 OBS의 내부 비동기 버퍼를 비활성화했더니 프레임 드롭이 발생했습니다.29 이는 지연 시간과 안정성 사이의 트레이드오프 관계를 보여주며, 수신 측에 작은 디지터 버퍼(de-jitter buffer)가 필요함을 시사합니다.이러한 정황들은 문제가 NDI 스트림 자체보다는 수신 애플리케이션의 구현에 있을 가능성이 매우 높다는 것을 강력하게 뒷받침합니다. 특히 NDI Studio Monitor와 같은 공식 툴에서는 문제가 되는 스트림이 원활하게 재생된다는 커뮤니티 보고 30는 원본 프록시 스트림 데이터가 네트워크를 통해 온전하게 도착하고 있음을 시사하는 강력한 증거입니다. 따라서 문제 해결의 초점은 애플리케이션의 CPU 사용률 프로파일링과 프레임 캡처 루프, 스레딩 모델에 대한 비판적인 검토에 맞춰져야 합니다.섹션 3: 근본 원인 분석: 네트워크 및 시스템 환경3.1 NDI 전송 프로토콜의 동작애플리케이션 코드가 주된 용의자이지만, 네트워크 및 시스템 환경 요인도 무시할 수 없습니다. NDI의 전송 프로토콜은 버전에 따라 다음과 같이 발전해왔습니다.Reliable UDP (RUDP, NDI 5): NDI 5의 기본 통신 메커니즘으로, UDP의 낮은 지연 시간과 TCP의 신뢰성을 결합한 최신 프로토콜입니다. 패킷 시퀀싱, 재전송 요청, 흐름 및 혼잡 제어 기능을 통해 실시간 멀티미디어 전송에 최적화되어 있습니다.Multipath TCP (NDI 4): 여러 네트워크 인터페이스 카드(NIC)를 동시에 활용하여 처리량을 극대화하고 네트워크 이중화를 강화하는 프로토콜입니다. 하지만 10Gbit와 1Gbit 인터페이스를 혼용할 경우, 네트워크 스위치의 혼잡 관리 문제로 인해 성능이 저하될 수 있습니다.UDP with Forward Error Correction (FEC, NDI 3): 데이터 정확성보다 적시성(timeliness)이 더 중요한 스트리밍 환경을 위한 프로토콜입니다. 송신 측에서 보낸 중복 데이터를 활용하여 수신 측에서 손실된 패킷을 복구하지만, 이 과정에서 추가적인 연산 처리가 필요합니다.Single TCP (NDI 1): 모든 NDI 버전에 걸쳐 지원되는 기본 호환성 프로토콜입니다. 다른 전송 모드들이 더 나은 성능을 제공하지만, Single TCP는 모든 NDI 클라이언트와의 기본적인 연결을 보장합니다.프로토콜 선택은 송신자와 수신자 간의 협상(negotiation)을 통해 이루어집니다. 예를 들어, 송신자가 최신 RUDP를 지원하더라도 수신 측 애플리케이션이나 운영체제, 또는 방화벽과 같은 네트워크 환경이 이를 지원하지 않으면 Single TCP와 같은 구형의 비효율적인 프로토콜로 대체될 수 있습니다.31 사용자 포럼에서는 NDI Access Manager에서 수신 모드를 'Auto'에서 'Reliable UDP'나 'Single TCP'로 수동 변경했을 때 스트림 안정성에 긍정적 또는 부정적인 영향을 미쳤다는 사례들이 보고되었습니다.32 이는 자동 협상 메커니즘이 특정 환경에서는 최적의 선택을 하지 못할 수 있음을 보여줍니다. NDI에서 제공하는 공식 Analysis Tool은 현재 사용 중인 연결 유형을 보고해주므로, 이를 통해 현재 어떤 프로토콜이 사용되고 있는지 진단할 수 있습니다.333.2 호스트 환경: WSL2 사례 연구와 네트워크 스택 오프로딩사용자가 Windows Subsystem for Linux 2 (WSL2) 환경에서 개발 중이라면, 이는 성능 문제의 중요한 변수가 될 수 있습니다. WSL2의 가상화된 네트워크 스택은 실시간 트래픽 처리 시 성능 저하를 일으키는 것으로 잘 알려져 있습니다.문제 1: NAT 대 미러 모드: 기본적으로 WSL2는 NAT(Network Address Translation) 방식의 가상 네트워크를 사용합니다. 이는 오버헤드를 추가하고 NDI 소스 검색(Discovery) 문제를 일으킬 수 있습니다. 최신 WSL2에서는 .wslconfig 파일에 networkingMode=mirrored 설정을 추가하여 이 문제를 해결할 수 있습니다. 이 모드는 WSL2가 호스트의 네트워크 인터페이스를 직접 공유하게 하여 호환성과 성능을 크게 향상시킵니다.34문제 2: Large Send Offload (LSO): LSO는 네트워크 어댑터가 대용량 TCP 패킷 분할 작업을 대신 처리하는 기능입니다. 이는 일반적으로 처리량을 높이는 데 도움이 되지만, 특정 네트워크 스택에서는 오히려 지연 시간을 증가시키고 문제를 일으킬 수 있으며, 이는 WSL2에서 널리 보고된 문제입니다.34 PowerShell 명령어를 사용하여 vEthernet (WSL) 가상 어댑터의 LSO 기능을 비활성화하는 것이 해결책이 될 수 있습니다.38이러한 WSL2 사례는 사용자가 해당 환경을 사용하지 않더라도 중요한 시사점을 제공합니다. 즉, 호스트 운영체제의 낮은 수준의 네트워크 스택 기능이 실시간 스트리밍 성능에 지대한 영향을 미칠 수 있다는 것입니다. 이는 문제에 대한 전체론적인 접근을 장려합니다. 프록시 스트림은 대역폭이 낮아 전체 대역폭 스트림보다 더 작고 많은 수의 패킷을 사용할 수 있습니다. LSO 문제나 TCP의 HOLB(Head-of-Line Blocking)과 같은 네트워크 문제는 이러한 작고 많은 패킷으로 구성된 스트림에 더 큰 영향을 미칠 수 있습니다. 따라서 전체 대역폭 스트림이 정상적으로 작동하더라도, 미묘한 네트워크 또는 OS 구성 문제가 프록시 스트림의 성능을 저하시키는 결정적인 요인이 될 수 있습니다.섹션 4: 체계적인 진단 및 해결 프레임워크4.1 1단계: NDI Analysis Tool을 이용한 병목 현상 분리가장 먼저 NDIAnalysis.exe 유틸리티를 사용하여 문제의 원인이 송신자, 네트워크, 수신자 중 어디에 있는지 분리해야 합니다.33 이 도구는 비디오를 디코딩하지 않으므로, 수신 애플리케이션의 디코딩 성능과 무관하게 네트워크 인터페이스에 도달하는 스트림의 순수한 상태를 측정할 수 있는 이상적인 기준선을 제공합니다.33 참고로, 이 분석 도구는 표준 NDI Tools 런처에 포함되어 있지 않을 수 있으며, NDI 공식 웹사이트에서 별도로 다운로드해야 할 수 있습니다.소스 이름 확인: 다음 명령어를 실행하여 네트워크상의 NDI 소스 목록과 정확한 이름을 확인합니다.BashNDIAnalysis.exe /find
프록시 스트림 분석 및 CSV 로깅: 확인된 소스 이름을 사용하여 프록시 스트림을 분석하고, 프레임 타이밍 데이터를 CSV 파일로 저장합니다. /csvvideo 인수에 지정된 파일은 명령어를 실행하는 현재 디렉토리에 생성되므로, 쓰기 권한이 있는 경로를 사용해야 합니다.44BashNDIAnalysis.exe /source:"My NDI Source (My Video)" /bandwidth:lowest /csvvideo:"proxy_analysis.csv"
4.2 2단계: 프레임 타이밍 데이터 해석 (진단 매트릭스)생성된 proxy_analysis.csv 파일을 Excel이나 Python 스크립트 같은 도구로 열어 분석합니다.45 NDI 문서에 따르면 주목해야 할 핵심 열은 다음과 같습니다 33:dTimestamp (ms): 송신자가 프레임 헤더에 기록한 타임스탬프 간의 간격. 이는 송신 측의 안정성을 측정합니다. 60fps의 경우 이상적인 값은 약 16.67ms입니다.dTime (ms): 수신 측에서 연속된 프레임이 도착한 시간 간의 간격. 이는 네트워크 지터(jitter)와 수신 측 스케줄링 지연을 측정합니다.이 두 데이터의 패턴을 비교하여 문제의 근본 원인을 높은 정확도로 추정할 수 있습니다.dTimestamp 패턴 (송신 간격)dTime 패턴 (도착 간격)유력한 근본 원인 및 다음 조치안정적 & 약 16.67ms안정적 & 약 16.67ms수신기 처리 병목. 스트림은 완벽하게 도착하고 있습니다. 문제는 recv_capture_v3 호출 이후의 애플리케이션 코드에 있습니다. 다음 조치: 애플리케이션의 CPU/GPU 사용률을 프로파일링합니다 (섹션 4.3).안정적 & 약 16.67ms불안정 (지터가 높고, 20-30ms를 초과하는 스파이크 발생)네트워크 지터 또는 수신기 스케줄링 문제. 네트워크가 프레임을 불규칙하게 전달하거나, 애플리케이션의 폴링/스레딩 방식이 지연을 유발하고 있습니다. 다음 조치: 네트워크 장비(스위치, 케이블)를 점검하고, 전송 프로토콜을 확인하며(섹션 3.1), 프레임 수신 루프를 검토합니다(섹션 2.1). 디지터 버퍼 구현을 고려합니다(섹션 4.4).불안정불안정송신 측 문제. 소스 애플리케이션/장비가 프레임을 안정적인 속도로 생성 또는 전송하지 못하고 있습니다. 다음 조치: 소스 장비의 성능 병목 현상을 조사합니다.안정적이지만 16.67ms 초과 (예: 약 25ms)안정적이지만 16.67ms 초과 (예: 약 25ms)의도적인 낮은 프레임레이트. 송신자가 의도적으로 낮은 프레임레이트(예: 40fps)의 프록시를 생성하고 있습니다. 이는 '정상' 동작이지만 원하는 결과가 아닙니다. 다음 조치: 송신 측의 설정을 확인합니다. 문제는 수신기에 있지 않습니다.4.3 3단계: 애플리케이션 프로파일링 및 코드 검토진단 매트릭스를 통해 수신기 병목 현상이 의심되는 경우, Visual Studio Profiler, Intel VTune, AMD uProf 등 표준 프로파일링 도구를 사용하여 코드의 어느 부분에서 CPU/GPU 시간을 과도하게 소모하는지 식별해야 합니다.다음은 섹션 2.4에서 다룬 함정들을 기반으로 한 코드 검토 체크리스트입니다.recv_capture_v3 호출이 논블로킹 타이트 루프(timeout=0) 내에 있습니까?프레임 버퍼를 NDIlib_recv_free_video_v2를 사용하여 사용 후에 정확히 해제하고 있습니까?비디오와 오디오 수신을 위해 별도의 스레드를 사용하고 있습니까?중요 스레드에 대해 스레드 우선순위와 CPU 선호도를 설정하는 것을 고려했습니까?동기화를 위해 NDI 타임스탬프를 올바르게 처리하고 있습니까?4.4 4단계: 고급 완화 전략 - 디지터 버퍼 구현진단 결과, 피할 수 없는 네트워크 지터(dTime이 불안정)가 문제의 원인으로 밝혀진 경우, 아키텍처 수준의 해결책을 고려할 수 있습니다. 이는 클라이언트 측에 디지터 버퍼(de-jitter buffer) 또는 링 버퍼(ring buffer)를 구현하는 것입니다.이 방식은 NDI로부터 수신한 프레임을 즉시 처리하는 대신 버퍼에 저장합니다. 그리고 별도의 렌더링 스레드가 이 버퍼에서 일정한 간격(예: 60fps의 경우 매 16.67ms)으로 프레임을 꺼내어 화면에 표시합니다. 이 방법은 버퍼 크기(예: 2~3 프레임)만큼의 고정된 지연 시간을 추가하는 대신, 네트워크의 불안정성을 사용자에게 보이지 않게 하여 완벽하게 부드러운 재생을 보장합니다. 이 기술은 커뮤니티에서 NDI Studio Monitor가 스트림을 "버퍼링"하거나 "부드럽게 만든다"고 묘사하는 현상의 배경이 되는 원리입니다.30섹션 5: 결론 및 전략적 권고5.1 유력한 원인 요약본 분석을 종합해 볼 때, NDI 프록시 스트림의 프레임레이트 저하 현상은 단일 원인이 아닌 복합적인 요인에 의해 발생할 가능성이 높습니다. 그러나 가장 유력한 주 원인은 수신 애플리케이션의 내부적인 처리 병목입니다. 이는 비효율적인 프레임 폴링 루프(CPU 스피닝)와 그로 인한 리소스 경합 문제이며, 기술 사양이 불분명하여 CPU에 의존적인 디코딩이 이루어질 수 있는 프록시 스트림의 특성에 의해 문제가 더욱 악화되는 것으로 판단됩니다.5.2 우선순위 기반 실행 계획문제 해결을 위해 다음의 체계적인 접근법을 권장합니다.진단 (Diagnose): NDIAnalysis.exe를 사용하여 프레임 타이밍 데이터를 CSV 파일로 캡처하고, 본 보고서의 **진단 매트릭스(Table 1)**를 활용하여 문제의 영역이 송신자, 네트워크, 또는 수신기 중 어디에 있는지 명확히 식별합니다.코드 검토 (Review Code): 진단 결과에 따라 문제 영역에 집중합니다. 수신기 문제로 판단될 경우, 프레임 캡처 루프가 CPU를 과도하게 점유하는지 최우선으로 검토합니다.블로킹 호출 즉시 적용 (Implement Blocking Call): 가장 빠르고 쉽게 시도할 수 있는 수정 사항으로, recv_capture_v3(timeout=0)를 recv_capture_v3(timeout=1000)과 같이 적절한 타임아웃 값을 가진 블로킹 호출로 변경합니다. 이 변경만으로도 CPU 사용률이 극적으로 감소하고 프레임레이트가 안정화될 수 있습니다.프로파일링 (Profile): 프로파일링 도구를 사용하여 애플리케이션의 CPU/GPU 핫스팟을 찾아내고, 병목 지점을 구체적으로 파악합니다.리팩토링 및 최적화 (Refactor & Optimize): 섹션 2에서 제시된 스레딩 우선순위, CPU 선호도 설정 등과 같은 모범 사례를 적용하여 코드를 최적화합니다.버퍼링 (Buffer): 네트워크 지터가 문제의 근본 원인으로 확인될 경우, 디지터 버퍼를 구현하여 스트림의 불안정성을 흡수하고 안정적인 출력을 보장합니다.5.3 장기적인 아키텍처 모범 사례향후 안정적인 NDI 애플리케이션을 개발하기 위해 다음과 같은 장기적인 아키텍처 원칙을 고려해야 합니다.스트림의 특성은 항상 예측 불가능할 수 있다고 가정하고 방어적으로 설계합니다.설계 초기 단계부터 효율적이고 논블로킹 방식의 스레딩 모델을 채택합니다.프레임 타이밍 로깅과 같은 진단 기능을 애플리케이션 내부에 포함시켜 문제 발생 시 신속하게 분석할 수 있도록 합니다.부드러운 재생이 요구되는 모든 애플리케이션에는 디지터 버퍼를 표준 구성 요소로 고려합니다.