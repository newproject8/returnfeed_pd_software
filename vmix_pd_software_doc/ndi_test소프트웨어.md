PyQtGraph 및 cyndilib를 활용한 NDI 비디오 프리뷰 소프트웨어 개발 계획1. 서론: NDI 프리뷰 소프트웨어 개요본 보고서는 PyQtGraph GUI 프레임워크와 cyndilib 라이브러리를 활용하여 네트워크 NDI(Network Device Interface) 비디오 소스를 실시간으로 미리 볼 수 있는 간단한 테스트 소프트웨어 개발 계획을 제시합니다. 이 소프트웨어는 NDI 소스 검색, 선택 및 미리 보기 재생 기능을 구현하는 데 중점을 둡니다.NDI 기술 소개NDI는 표준 IP 네트워크를 통해 고품질 비디오 및 오디오를 안정적으로 전송하고 수신할 수 있도록 지원하는 초저지연 비디오 연결 기술입니다.1 이 기술은 라이브 프로덕션 및 방송 분야에서 널리 채택되고 있습니다.4 NDI의 핵심은 비디오 전송의 지연 시간을 최소화하는 데 있으므로, 이를 활용하는 파이썬 애플리케이션 또한 높은 성능과 실시간 처리 능력을 갖추어야 합니다. 이러한 성능 요구사항은 PyQtGraph와 cyndilib와 같은 라이브러리를 선택하는 데 결정적인 역할을 합니다. cyndilib는 성능을 위해 Cython으로 래핑되어 있으며 1, PyQtGraph는 NumPy와 Qt의 GraphicsView 프레임워크를 활용하여 속도에 최적화되어 있습니다.5 이러한 라이브러리 선택은 단순히 임의적인 것이 아니라, NDI의 본질적인 성능 요구 사항에 부응하기 위한 근본적인 설계 결정이며, 이는 데이터 전송 효율성과 멀티스레딩의 필요성을 포함한 전체 아키텍처 접근 방식에 영향을 미칩니다.프로젝트 목표이 프로젝트의 주요 목표는 다음과 같습니다:
간단하고 기능적인 파이썬 기반 NDI 비디오 미리 보기 애플리케이션을 개발합니다.
NDI 소스 검색, 선택 및 실시간 비디오 재생과 같은 핵심 기능을 시연합니다.
GUI를 위한 PyQtGraph와 NDI 처리를 위한 cyndilib 통합을 위한 테스트 베드 역할을 수행합니다.
핵심 기술
PyQt/PySide: 강력하고 크로스 플랫폼 GUI 프레임워크입니다.5
PyQtGraph: PyQt와 NumPy를 기반으로 구축된 특수 플로팅 및 이미지 디스플레이 라이브러리로, 속도와 실시간 데이터 처리에 최적화되어 있습니다.5 특히 RawImageWidget은 빠른 비디오 디스플레이에 사용됩니다.10
cyndilib: Cython으로 작성된 NDI SDK의 고성능 파이썬 래퍼로, 검색 및 수신과 같은 NDI 기능에 직접 접근할 수 있도록 합니다.1
2. 실시간 성능을 위한 아키텍처 설계파이썬 GUI에서 원활한 NDI 비디오 미리 보기를 구현하려면 멀티스레딩과 효율적인 데이터 처리에 중점을 둔 신중한 아키텍처 계획이 필요합니다.멀티스레딩 전략PyQt GUI 애플리케이션은 본질적으로 단일 스레드 방식으로 작동합니다. NDI 소스를 지속적으로 검색하거나 비디오 프레임을 캡처하는 것과 같은 장시간 실행 작업은 메인 GUI 스레드를 차단하여 사용자 인터페이스가 멈추고 응답하지 않게 만들 수 있습니다.5 이러한 문제를 해결하고 GUI의 응답성을 유지하기 위해, NDI 검색, 비디오 수신 및 프레임 처리와 같은 계산 집약적인 작업은 별도의 워커 스레드로 오프로드되어야 합니다.5PyQt는 이러한 워커 스레드를 관리하기 위해 QThread를 제공합니다. NDI 작업의 핵심 로직은 QObject 서브클래스에 상주하며, 이 클래스는 moveToThread()를 사용하여 QThread 인스턴스로 이동됩니다.5 GUI 스레드와 워커 스레드 간의 안전하고 효율적인 통신을 위해 시그널(Signals)과 슬롯(Slots) 메커니즘이 사용됩니다.5 워커 스레드는 새로운 데이터(예: 검색된 NDI 소스, 새 비디오 프레임) 또는 상태 업데이트(예: 연결 상태)를 GUI 스레드에 알리기 위해 시그널을 방출합니다. GUI 스레드는 이러한 시그널에 연결된 슬롯을 통해 UI 요소를 업데이트(예: 드롭다운 채우기, 비디오 프레임 표시)하여 GUI가 멈추는 것을 방지합니다.5애플리케이션 종료 시 QThread.terminate() 메서드는 강제 종료로 인해 예외를 발생시키거나 리소스 누수를 유발할 수 있으므로 피해야 합니다. 대신, QThread.quit() 및 QThread.wait()와 결합된 플래그 기반 접근 방식이 깔끔한 종료를 위해 권장됩니다.16 terminate()는 스레드를 강제로 중지시켜 리소스가 열려 있거나 일관되지 않은 상태로 남을 수 있습니다. 반면 quit()는 스레드의 이벤트 루프에 정상적으로 종료하도록 신호를 보내, 워커 객체의 run() 메서드(또는 이에 상응하는 메서드)가 현재 작업을 완료하고 스레드가 실제로 중지되기 전에 필요한 정리를 수행할 수 있도록 합니다. 이는 NDI의 수신기 연결 해제 및 파인더 종료와 같은 리소스 관리에 필수적입니다. 이러한 적절한 스레드 관리는 응답성뿐만 아니라 애플리케이션의 안정성을 보장하고, 특히 버퍼와 연결이 지속적으로 활성화되는 실시간 비디오 처리에서 리소스 고갈을 방지하는 데 매우 중요합니다. 이는 "간단한 테스트 소프트웨어"의 신뢰성에 직접적인 영향을 미칩니다.비디오 프레임 파이프라인cyndilib.Receiver는 NDI 비디오 프레임을 캡처합니다. 수신기와 연결된 VideoFrameSync 객체는 video_frame.get_array()를 사용하여 원시 비디오 데이터를 NumPy 배열로 직접 접근할 수 있도록 합니다.18PyQtGraph.RawImageWidget은 매우 빠른 비디오 디스플레이를 위해 특별히 설계되었으며, setImage() 메서드를 통해 NumPy 배열을 직접 받을 수 있습니다.10 이는 QImage/QPixmap으로 먼저 변환하는 것보다 훨씬 효율적이며, 변환 과정에서 발생하는 오버헤드를 줄일 수 있습니다.21 RawImageWidget에 NumPy 배열을 직접 전달하는 것은 중간 Qt 이미지 변환(예: QImage, QPixmap)을 우회합니다. 이러한 변환은 종종 CPU에 부담을 주며 고해상도 비디오 스트림에서 지연 시간을 유발할 수 있습니다. PyQtGraph가 NumPy 배열을 직접 사용하는 것은 내부적으로 OpenGL 텍스처를 더 효율적으로 활용한다는 것을 의미합니다.22 이러한 RawImageWidget의 선택은 "실시간 미리 보기" 요구 사항을 달성하는 데 근본적이며, 디스플레이 측면에서 CPU 부담을 줄여 NDI 디코딩 및 기타 작업에 더 많은 리소스를 할당할 수 있도록 합니다.표 1: cyndilib의 NDI 소스 검색 메서드
메서드 이름설명애플리케이션 내 목적관련 스니펫 IDFinder.open()NDI 검색을 시작합니다.애플리케이션 시작 시 자동 검색 초기화.18Finder.wait_for_sources(timeout_ms)새 소스가 추가되거나 제거될 때까지 기다립니다.수동 검색 버튼 클릭 시 소스 목록 업데이트 대기.26Finder.get_source_names()현재 검색된 NDI 소스 이름 목록을 반환합니다.드롭다운 메뉴를 채우고 업데이트하는 데 사용됩니다.18Finder.get_source(name)지정된 이름의 NDI 소스 객체를 반환합니다.드롭다운에서 선택된 소스에 대한 수신기를 설정하는 데 사용됩니다.18Finder.set_change_callback(callback_func)NDI 소스 목록이 변경될 때 호출될 콜백 함수를 설정합니다.소스 목록의 동적 업데이트를 GUI에 비동기적으로 알립니다.18Finder.close()NDI 검색 인스턴스를 종료하고 리소스를 해제합니다.애플리케이션 종료 시 깔끔한 리소스 정리.18
이 표는 핵심 cyndilib.Finder API에 대한 빠른 참조를 제공하여 사용자의 소스 검색 요구 사항을 직접적으로 다룹니다. 초기 스캔, 지속적인 모니터링 및 온디맨드 업데이트에 어떤 메서드가 사용되는지 명확히 하여 구현 프로세스를 간소화합니다. set_change_callback을 통한 NDI 검색의 이벤트 기반 특성을 강조하며, 이는 지속적인 폴링 없이 응답성 있는 GUI를 위해 중요합니다.3. NDI 소스 검색 구현애플리케이션은 cyndilib.Finder를 활용하여 네트워크에서 NDI 소스를 찾습니다.시작 시 자동 검색애플리케이션이 시작되면 cyndilib.finder.Finder 인스턴스를 생성하고 finder.open()을 호출하여 검색 프로세스를 시작해야 합니다.18 NDI 검색은 모든 소스를 찾는 데 몇 초가 걸릴 수 있습니다.26 따라서 소스 드롭다운의 초기 채우기는 짧은 지연 후에 또는 안정적인 목록이 확보될 때까지 finder.get_source_names()를 지속적으로 확인하여 수행되어야 합니다.finder.set_change_callback() 메서드는 이 과정에서 매우 중요합니다. 이 메서드는 사용 가능한 NDI 소스 목록이 변경될 때마다 GUI에 비동기적으로 알림을 보냅니다.18 이 콜백은 소스 드롭다운을 업데이트하는 트리거 역할을 해야 합니다.수동 검색 버튼"NDI 소스 탐색" 버튼은 사용자가 소스 목록을 수동으로 새로 고칠 수 있도록 합니다. 이 버튼을 클릭하면 NDI 워커 스레드에서 finder.wait_for_sources(timeout_ms)(예: C++ 예제에서 5000ms 26)가 호출됩니다. 이 호출은 새 소스가 발견되거나 타임아웃이 발생할 때까지 스레드를 차단합니다. wait_for_sources가 반환되면 finder.get_source_names()를 다시 호출하여 업데이트된 목록을 검색하고, 이를 시그널을 통해 GUI 스레드로 전달하여 드롭다운을 업데이트해야 합니다.소스 선택 드롭다운 (QComboBox)QComboBox 위젯은 소스 선택에 사용됩니다. 초기에는 첫 번째 선택 불가능한 항목으로 "ndi소스를 선택하세요"를 표시해야 합니다. NDI 소스가 검색되면(자동 또는 수동으로), 해당 이름(finder.get_source_names()에서 얻음)이 드롭다운을 채우고, 기존의 플레이스홀더를 대체합니다. 드롭다운에서 항목을 선택하면 시그널이 발생하며, 이 시그널은 선택된 소스에 대한 cyndilib.Receiver를 설정하는 NDI 워커 스레드의 슬롯에 연결됩니다.4. NDI 비디오 수신 및 미리 보기 디스플레이이 섹션에서는 선택된 NDI 소스에서 비디오 프레임을 수신하고 PyQtGraph RawImageWidget에 효율적으로 표시하는 방법을 자세히 설명합니다.수신기 설정드롭다운에서 소스를 선택하면 cyndilib.receiver.Receiver 인스턴스가 생성되거나 재구성됩니다.18 Receiver는 원하는 RecvColorFormat 및 RecvBandwidth로 초기화되어야 합니다.18 선택된 NDI 소스 객체(finder.get_source()에서 얻음)는 receiver.set_source(source)에 전달됩니다.18 cyndilib.video_frame.VideoFrameSync 객체는 비디오 프레임을 획득하는 데 필수적이며, 수신기의 frame_sync 속성에 설정되어야 합니다: receiver.frame_sync.set_video_frame(video_frame).18프레임 획득 및 디스플레이 루프NDI 워커 스레드 내의 전용 루프는 receiver.frame_sync.capture_video()를 지속적으로 호출하여 새 프레임을 획득합니다.18 이 메서드는 새 프레임이 사용 가능해지거나 타임아웃이 발생할 때까지 차단됩니다. 프레임이 캡처되면 video_frame.get_array()를 사용하여 NumPy 배열로 데이터가 검색됩니다.18 이 NumPy 배열(비디오 프레임을 나타냄)은 워커 스레드에서 GUI 스레드의 슬롯으로 시그널을 통해 방출됩니다. GUI 스레드의 슬롯은 NumPy 배열을 받아 self.rawImageWidget.setImage(numpy_array)에 직접 전달하여 디스플레이를 효율적으로 업데이트합니다.10cyndilib 예제는 종종 OpenCV로 표시하기 위해 cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)를 사용합니다.18 그러나 PyQtGraph.RawImageWidget은 RGBA 또는 RGBX 형식을 직접 처리할 수 있습니다.11 이는 RGBA를 BGR로 변환하는 추가 변환 단계가 불필요할 수 있음을 의미하며, 잠재적으로 CPU 부하와 지연 시간을 줄일 수 있습니다. RecvColorFormat.RGBX_RGBA 또는 RecvColorFormat.RGBA(알파 채널이 필요한 경우)를 선택하는 것이 PyQtGraph의 직접적인 소비에 최적입니다. PyQtGraph.RawImageWidget의 setImage 메서드는 3채널(RGB) 또는 4채널(RGBA) 배열을 직접 지원합니다. cyndilib는 RGBX_RGBA 형식으로 프레임을 전달할 수 있습니다.28 PyQtGraph가 RGBA를 직접 표시할 수 있다면, cv2.cvtColor 단계는 중복되어 CPU 사이클을 절약하고 지연 시간을 줄일 수 있습니다. 픽셀 파이프라인의 이러한 작은 최적화는 특히 고해상도 NDI 스트림의 경우 "실시간 성능" 목표에 크게 기여할 수 있습니다. 이는 통합된 모든 라이브러리의 데이터 형식 및 기능을 이해하는 것이 중요함을 강조합니다.원본 재생 vs. 프록시 재생사용자의 "원본 재생" 및 "프록시 재생" 요구 사항은 cyndilib.wrapper.ndi_recv.RecvBandwidth 옵션에 직접 매핑됩니다.28
원본 재생 (Original Playback): RecvBandwidth.highest에 해당합니다. 이는 NDI 스트림을 최대 품질과 해상도로 수신하려고 시도합니다.
프록시 재생 (Proxy Playback): RecvBandwidth.lowest에 해당합니다. 이는 NDI 수신기에 낮은 대역폭, 잠재적으로 낮은 해상도 또는 품질의 스트림을 요청하도록 지시하며, 이는 많은 소스를 모니터링하거나 대역폭이 제한된 네트워크에서 유용할 수 있습니다.
이 선택을 위해 QRadioButton 그룹 또는 QComboBox를 사용할 수 있습니다. 이 옵션을 변경하면 cyndilib.Receiver를 재구성(새로운 bandwidth를 설정하고 fastest가 사용되는 경우 color_format도 설정)하고 소스에 다시 연결해야 합니다.표 2: PyQtGraph를 위한 cyndilib 비디오 수신 픽셀 형식
cyndilib.RecvColorFormat 옵션설명해당 NumPy 배열 형태PyQtGraph.RawImageWidget 적합성관련 스니펫 IDRGBX_RGBA알파 채널이 있는 경우 RGBA, 그렇지 않으면 RGBX를 전달합니다.(height, width, 4)직접 사용 가능, 최적의 성능.29UYVY_RGBA알파 채널이 있는 경우 RGBA, 그렇지 않으면 UYVY를 전달합니다.(height, width, 4) 또는 (height, width, 2) (UYVY)UYVY의 경우 변환 필요, RGBA는 직접 사용 가능.29fastest들어오는 비디오 신호에 대해 가장 빠른 사용 가능한 색상 형식을 사용하여 비디오를 디코딩합니다. 일반적으로 최상의 성능을 위해 사용됩니다.플랫폼 및 소스에 따라 다름.일반적으로 직접 사용 가능, 성능 최적화.28best들어오는 코덱에 가장 가까운 형식으로 비디오를 제공하여 최고 품질을 제공합니다. 16bpp 색상 수신에 유용합니다.플랫폼 및 소스에 따라 다름.변환이 필요할 수 있음, 품질 최적화.28
이 표는 cyndilib의 출력을 PyQtGraph의 입력과 통합하는 기술적 과제를 직접적으로 다룹니다. 올바르고 효율적인 비디오 디스플레이에 중요한 픽셀 형식에 대한 명확한 지침을 제공하여 사용자가 이미지 데이터 표현과 관련된 일반적인 문제를 피할 수 있도록 돕습니다. 이 표는 사용자가 이미지 품질과 성능 간의 트레이드오프에 대해 정보에 입각한 결정을 내릴 수 있도록 지원하며, 이는 실시간 비디오 애플리케이션에서 흔히 발생하는 문제입니다. 또한 최소한의 후처리가 필요한 형식을 선택하여 최적화할 수 있는 잠재적 영역을 강조합니다.표 3: NDI 비디오 재생 모드 및 cyndilib 대역폭 옵션
사용자 옵션cyndilib.RecvBandwidth Enum설명사용 사례/이점관련 스니펫 ID원본 재생 (Original Playback)highestNDI 스트림을 최대 품질과 해상도로 수신합니다.최고 품질의 미리 보기, 전체 충실도.28프록시 재생 (Proxy Playback)lowest낮은 대역폭, 잠재적으로 낮은 해상도 또는 품질의 스트림을 요청합니다.여러 소스 모니터링, 대역폭 절약, 네트워크 부하 감소.28
이 표는 사용자의 기능 요구 사항을 cyndilib API 선택으로 직접 변환하여 각 재생 모드의 기술적 영향을 설명합니다. 이는 NDI 스트림에 내재된 품질과 성능 간의 트레이드오프를 사용자가 이해하는 데 도움이 됩니다. 이 기능을 통해 사용자는 애플리케이션을 다양한 네트워크 조건 또는 모니터링 시나리오에 맞게 조정할 수 있습니다. 이는 특히 다양한 NDI 소스가 다양한 특성을 가질 수 있는 테스트 환경에서 시스템 리소스 및 사용자 경험을 관리하기 위한 실용적인 제어 기능입니다.5. 사용자 인터페이스 구성 요소 및 레이아웃GUI는 논리적이고 사용자 친화적인 방식으로 배열된 PyQt 위젯을 사용하여 구축됩니다.메인 창 (QMainWindow 또는 QWidget)기본 애플리케이션 창은 모든 구성 요소를 수용합니다. 요소의 수직 스태킹을 위해 QVBoxLayout을 메인 레이아웃으로 고려할 수 있습니다.비디오 미리 보기 영역PyQtGraph.RawImageWidget 인스턴스는 NDI 비디오 피드를 표시하기 위해 눈에 띄게 배치됩니다. 이 위젯은 성능에 최적화되어 있습니다.10 들어오는 비디오 해상도에 맞게 동적으로 크기를 조정하거나 레이아웃 내에서 확장되도록 설정해야 합니다.제어 패널 (예: QHBoxLayout)수평 레이아웃은 제어 요소를 그룹화할 수 있습니다.
NDI 소스 검색 버튼 (QPushButton): "NDI 소스 탐색"으로 레이블이 지정됩니다. 이 버튼은 워커 스레드에서 수동 소스 검색을 트리거합니다.
NDI 소스 선택 드롭다운 (QComboBox): 검색된 NDI 소스로 채워집니다. currentIndexChanged 또는 activated 시그널은 선택된 소스에서 비디오 수신을 시작하는 슬롯에 연결됩니다.
재생 모드 선택 (QComboBox 또는 QRadioButtons):

"원본 재생" 및 "프록시 재생" 옵션이 있는 QComboBox는 이를 구현하는 깔끔한 방법입니다.
또는 두 개의 QRadioButton 위젯을 함께 그룹화하여 하나만 선택되도록 할 수 있습니다.
이 선택을 변경하면 cyndilib.Receiver의 대역폭을 재구성하는 시그널이 트리거됩니다.


상태 표시줄 (선택 사항이지만 권장)QStatusBar는 "NDI 소스 검색 중...", "[소스 이름]에 연결됨", "NDI 소스를 찾을 수 없음" 또는 "수신 중 [해상도] @"와 같은 메시지를 표시할 수 있습니다. 이는 사용자에게 중요한 피드백을 제공합니다.6. 주요 고려 사항 및 모범 사례성능 최적화
cyndilib의 Cython 기반: cyndilib는 성능을 위해 Cython으로 작성되었으며, NDI SDK를 직접 래핑합니다.1 이는 NDI 특정 작업이 이미 C 수준에서 고도로 최적화되어 있음을 의미합니다.
NumPy 통합: cyndilib가 프레임을 NumPy 배열로 반환하는 기능 18과 PyQtGraph가 이러한 배열을 직접 소비하는 기능 10은 데이터 복사 및 변환 오버헤드를 최소화합니다. 이는 높은 프레임 속도와 해상도에 매우 중요합니다.
디스플레이를 위한 OpenGL: PyQtGraph는 렌더링을 위해 OpenGL을 활용합니다.6 RawImageWidget이 이를 추상적으로 처리하지만, 기본 렌더링이 GPU 가속화된다는 것을 이해하는 것은 성능 기대치에 중요합니다. 매우 높은 성능 시나리오 또는 사용자 정의 효과의 경우, Pixel Buffer Object(PBO)를 통한 비동기 전송을 통해 직접적인 OpenGL 텍스처 업데이트(예: QOpenGLWidget 및 PyOpenGL 사용)를 탐색할 수 있습니다.30

RawImageWidget은 고도로 최적화되어 있지만, 극도로 까다로운 시나리오(예: 4K 이상의 NDI 스트림, 복잡한 실시간 효과)의 경우 OpenGL 텍스처 관리(PBO, 직접 glTexSubImage2D 호출)에 대한 더 깊은 이해가 필요할 수 있습니다. 이는 PyQtGraph의 추상화를 넘어선 영역입니다. RawImageWidget은 "확장되지 않은 모드에서만 가장 빠르다"고 언급됩니다.11 확장된 모드 또는 고도로 사용자 정의된 렌더링, 또는 PyQtGraph의 추상화가 성능을 제한하는 경우, 직접적인 OpenGL 접근은 GPU 메모리 및 렌더링 파이프라인에 대한 더 세밀한 제어를 제공합니다. PBO는 비동기 데이터 전송을 가능하게 하여 CPU-GPU 동기화 지연을 방지합니다.22 이는 극단적인 해상도 또는 프레임 속도에서 RawImageWidget의 성능 한계를 시사합니다. "간단한 테스트 소프트웨어"의 경우 RawImageWidget으로 충분하지만, 프로덕션 수준의 고성능 뷰어의 경우 사용자는 사용자 정의 QOpenGLWidget 구현으로 전환해야 할 수 있습니다.


디코딩을 위한 하드웨어 가속: NDI SDK 자체는 Windows(NVDEC, MFT) 및 macOS(Video Toolbox)와 같은 플랫폼에서 HX(H.264/H.265) 코덱에 대한 하드웨어 가속을 활용할 수 있습니다.34 cyndilib가 이를 추상화하지만, 기본 NDI 라이브러리가 디코딩을 위해 GPU 리소스를 활용할 수 있어 CPU 부담을 더욱 줄일 수 있다는 점을 아는 것이 유용합니다. PyAV 또한 하드웨어 디코딩을 지원합니다.12

NDI SDK의 기본 하드웨어 디코딩 기능 34은 NDI 비디오 수신에 대한 CPU 부하가 NDI 소스의 코덱 및 수신기 플랫폼에 따라 예상보다 낮을 수 있음을 의미합니다. 이는 cyndilib가 상속받는 "숨겨진" 성능 이점입니다. cyndilib는 NDI SDK의 래퍼이므로 2, 기본 NDI SDK가 하드웨어 디코딩을 수행하면 cyndilib는 명시적인 파이썬 코드 없이 간접적으로 이점을 얻습니다. 이는 디코딩에 대한 CPU 부담이 순수 소프트웨어 기반보다 잠재적으로 낮다는 것을 의미합니다. 이는 성능에 긍정적인 "파급 효과"를 가져옵니다. 즉, 병목 현상이 NDI 디코딩 자체(호환되는 하드웨어 및 NDI 스트림 유형 가정)보다는 최적화되지 않은 경우 파이썬 수준의 데이터 전송 또는 GUI 렌더링이 될 가능성이 더 높다는 것을 의미합니다. 이는 효율적인 NumPy-to-PyQtGraph 통합의 중요성을 다시 한번 강조합니다.


오류 처리
NDI 소스를 찾을 수 없는 경우에 대한 검사(예: on_finder_change 콜백에서 if len(ndi_source_names) == 0: 사용)를 구현합니다.18 사용자에게 적절한 메시지를 표시합니다.
선택한 NDI 소스를 사용할 수 없게 되는 경우(receiver.is_connected() 확인)를 처리합니다.18
애플리케이션이 종료될 때 Finder 및 Receiver 인스턴스가 정상적으로 종료되도록 합니다.18 이는 MainWindow의 closeEvent에서 finder.close() 및 receiver.disconnect()를 호출하는 것을 포함합니다.16
의존성
PyQt5 또는 PySide2/6 (PyQt6/PySide6는 PyQt5/PySide2의 현대적인 대안으로, 유사한 API를 제공합니다).5
PyQtGraph.5
cyndilib (pip install cyndilib로 설치 가능).2
numpy (PyQtGraph 및 cyndilib 프레임 처리를 위한 핵심 종속성).11
참고: 직접적인 OpenGL 렌더링을 위해 PyOpenGL을 사용하는 경우 추가 종속성이 됩니다.33
7. 결론본 보고서는 GUI를 위한 PyQtGraph와 NDI 처리를 위한 cyndilib를 사용하여 간단한 NDI 비디오 미리 보기 소프트웨어를 개발하기 위한 포괄적인 계획을 상세히 설명했습니다. QThread와 시그널/슬롯을 사용한 견고한 멀티스레딩 아키텍처를 채택하고, cyndilib의 Cython 구현과 PyQtGraph의 직접적인 NumPy 배열 처리에서 내재된 성능 최적화를 활용함으로써, 애플리케이션은 실시간으로 응답하는 NDI 비디오 미리 보기를 달성할 수 있습니다. 이 설계는 자동 및 수동 소스 검색, 소스 선택, 유연한 재생 모드(원본/프록시)를 포함한 주요 요구 사항을 충족합니다.보다 견고한 애플리케이션을 위한 잠재적 다음 단계:
오디오 통합: cyndilib.Receiver를 확장하여 NDI 오디오 프레임도 캡처하고 재생합니다.
메타데이터 처리: NDI 소스와 관련된 NDI 메타데이터를 표시합니다.
고급 오류 처리: 보다 정교한 오류 로깅 및 사용자 피드백 메커니즘을 구현합니다.
성능 모니터링: 실제 프레임 속도, 해상도 및 CPU/GPU 사용량을 표시하는 GUI 요소를 추가합니다.
사용자 정의 OpenGL 렌더링: 극단적인 성능 또는 특수 시각 효과를 위해 RawImageWidget을 사용자 정의 QOpenGLWidget 서브클래스로 교체하여 텍스처 업데이트 및 셰이더에 대한 더 세밀한 제어를 제공합니다.
NDI 송신 기능: 애플리케이션에서 비디오를 NDI 소스로 송신하는 기능을 추가합니다.
구성 지속성: 애플리케이션 설정(예: 마지막으로 선택한 NDI 소스)을 저장하고 로드합니다.
